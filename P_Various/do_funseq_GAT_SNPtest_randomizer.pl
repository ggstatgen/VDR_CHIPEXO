#!/usr/bin/perl
use strict;
use warnings;
use File::Basename;
use Getopt::Long;
use IO::Zlib;
use List::Util qw(sum);
use Statistics::R;

#6/7/2015
#I read the following article
#http://www.cureffi.org/2013/01/29/sampling-a-matching-distribution-for-bootstrapping/

#Even if I create a frequency matched random background for GAT, I CANNOT guarantee that the 10,000 samples are frequency matched to the foreground.
#So here, I try to run a randomisation myself. I use the 1,000 frequency matched samples of the foreground generated by SNPsnap.
#I check the overlap of the foreground with the GRASP CEU ld blocks and with each of the one thousands, then I report empyrical p-values.

#INPUTs
#1 [SEGMENTS]foreground SNP, bed. Intersect with GWAS block
#2 [ANNOTATION] GRASP GWAS CEU LD blocks around genome wide significan snps.
#3 [BACKGROUND] output of SNPsnap, with one randomization set per column. Turn each column into a temp bed and intersect with GWAS blocks

#first gather intersections between all foreground snps and each sub-bed obtained from the annotation, using each GWAS term. Keep this data
#then, gather intersections between all 1000 sets of background snps and each sub-bed obtained from the annotation. 
#COMPARE these in some way. Z-score? Z test

my $BEDTOOLS = "/net/isi-scratch/giuseppe/tools/bedtools-2.22.1/bin/bedtools";

my $INPUT_FOREGROUND;
my $INPUT_SNPSNAP;
my $INPUT_GRASP_CEU_BLOCKS;
GetOptions(
        'fg=s'      =>\$INPUT_FOREGROUND,
        'bg=s'      =>\$INPUT_SNPSNAP,
        'gwasld=s'  =>\$INPUT_GRASP_CEU_BLOCKS,
);
#$INPUT_GRASP_CEU_BLOCKS = "/net/isi-scratch/giuseppe/indexes/GWAS_GRASP/LD_PLINK_CEU_GRASP2_plus_Beecham2013.bed.gz";
#from the above, intersect with foreground, and generated one bed FOR EACH phenotype that intersects.
##my $INPUT_ANNOTATION = "/net/isi-scratch/giuseppe/VDR/ALLELESEQ/funseq2/out_allsamples_plus_qtl_ancestral/LDCLUMP_VDRBV-REP/GAT_ANNOTATION/GAT_LD_PLINK_CEU_GRASP_recur_hg19.bed.gz";
#$INPUT_SNPSNAP = "/net/isi-scratch/giuseppe/VDR/ALLELESEQ/funseq2/out_allsamples_plus_qtl_ancestral/LDCLUMP_VDRBV-REP/RANDOMIZER/BG_SNPSNAP.txt.gz";
#$INPUT_SNPSNAP = "/net/isi-scratch/giuseppe/VDR/ALLELESEQ/funseq2/out_allsamples_plus_qtl_ancestral/LDCLUMP_VDRBV-REP/RANDOMIZER/BG_SNPSNAP.txt.gz";
#$INPUT_FOREGROUND = "/net/isi-scratch/giuseppe/VDR/ALLELESEQ/funseq2/out_allsamples_plus_qtl_ancestral/LDCLUMP_VDRBV-REP/RANDOMIZER/FG.bed.gz";

if(!$INPUT_FOREGROUND){
	print "USAGE: do_funseq_GAT_SNPtest_randomizer.pl -fg=<FG> -bg=<BG> -gwas=<GWASLD>\n";
    print "<FG> b37 bed.gz containing the foreground SNPs\n";
    print "<BG> gzipped SNPsnap output matrix with the random frequency matched sets\n";
    print "<GWASLD> b37 gzipped bed containing GRASP GWAS tag snps mapped to LD blocks\n";
    exit 1;
}
if(!$INPUT_SNPSNAP){
	print "USAGE: do_funseq_GAT_SNPtest_randomizer.pl -fg=<FG> -bg=<BG> -gwas=<GWASLD>\n";
    print "<FG> b37 bed.gz containing the foreground SNPs\n";
    print "<BG> gzipped SNPsnap output matrix with the random frequency matched sets\n";
    print "<GWASLD> b37 gzipped bed containing GRASP GWAS tag snps mapped to LD blocks\n";
    exit 1;
}
if(!$INPUT_GRASP_CEU_BLOCKS){
	print "USAGE: do_funseq_GAT_SNPtest_randomizer.pl -fg=<FG> -bg=<BG> -gwas=<GWASLD>\n";
    print "<FG> b37 bed.gz containing the foreground SNPs\n";
    print "<BG> gzipped SNPsnap output matrix with the random frequency matched sets\n";
    print "<GWASLD> b37 gzipped bed containing GRASP GWAS tag snps mapped to LD blocks\n";
    exit 1;
}

my($basename, $directory) = fileparse($INPUT_FOREGROUND);
$basename =~ s/(.*)\..*/$1/;
my $out_temp_buffer         =  $directory . $basename . '_TEMP_diseaseblocks.tsv';
my $out_temp_buffer_ph_list =  $directory . $basename . '_TEMP_diseaseblocks_phlist.txt';
my $out_results_noncorrected =  $directory . $basename . '_RESULTS.txt';

#######
#0 Transpose initial SNPsnap matrix
#######
my @rows = ();
my @transposed_SNPsnap = ();
tie *FILE,   'IO::Zlib', $INPUT_SNPSNAP, "rb";
my $row = 0;
while (<FILE>)	{
	chomp;
	next if($_ eq '');
	next if($_ =~ /^#/);
	next if($_ =~ /^Input_SNP/); # get rid of header
	my @line = split("\t", $_);
	shift @line; # first column is input data
	
	foreach my $column (@line){
    	push @{$rows[$row]}, $column;
  	}
 	$row++;
 	#push @rows, [ split /\t/ ];
}
for my $row (@rows) {
  for my $column (0 .. $#{$row}) {
    push(@{$transposed_SNPsnap[$column]}, $row->[$column]);
  }
}
close FILE;

###########
#1 intersect FG with disease LD blocks to see which traits are represented.
###########
#intersect disease blocks with foreground SNPs
system "$BEDTOOLS intersect -wo -a $INPUT_GRASP_CEU_BLOCKS -b $INPUT_FOREGROUND > $out_temp_buffer";
#collect intersecting phenotypes
system "cut -f 12 $out_temp_buffer | sort | uniq > $out_temp_buffer_ph_list";

#get phenotype list from file
my %phenotype_map;
open (my $instream,  q{<}, $out_temp_buffer_ph_list) or die("Unable to open $out_temp_buffer_ph_list : $!");
while(<$instream>){
	chomp;
	next if($_ eq '');
	$phenotype_map{lc($_)} = 1;
}
close $instream;
#now we have a list of phenotypes seen in correspondance of foreground variants. Create a temp bed for each term and intersect with foreground and with each dynamically generated background bed. Store number of intersections. Calculate z-scores and fdr correct

my $out_temp_buffer_singleph_bed           = $directory . $basename . '_TEMP_singleph.bed';
my $out_temp_buffer_singleph_bed_processed = $directory . $basename . '_TEMP_singleph_sorted.bed';
my %ph_to_stats;
my $hash_keys_counter = 1;
my $hash_keys_total = scalar keys %phenotype_map;
print "Processing..\n";
foreach my $item (sort keys %phenotype_map){
	my $METRIC_FG = (); my $METRIC_BG; my @METRIC_BG = ();
	
	print "Analysing enrichment for GWAS term: \"$item\" (term $hash_keys_counter/$hash_keys_total)\n";
	$hash_keys_counter++;
	
	#create trait bed - turn this into sub
	create_phenotype_bed($item, $out_temp_buffer_singleph_bed, $out_temp_buffer_singleph_bed_processed);
	#now we have a bed with all the LD blocks specific to ONE phenotype. By definition, this bed should have at least 1 intersection with the foreground. 
	#check and report intersections with fg
	#report intersection with all the 1000 background columns
	$METRIC_FG = `$BEDTOOLS intersect -a $INPUT_FOREGROUND -b $out_temp_buffer_singleph_bed_processed | wc -l`;
	chomp $METRIC_FG;
	if($METRIC_FG eq '0'){
		print STDERR "ERROR: by definition this number should not be zero: $METRIC_FG. Aborting..\n";
		exit -1;
	}
	#generate background beds, intersect each with this phenotype's bed and save all intersections
	my $out_temp_INPUT_BACKGROUND              = $directory . $basename . '_TEMP_backgroundset.bed';
	#fill, intersect, unlink, loop
	foreach my $row (@transposed_SNPsnap) { #each row is a randomized sample of #foreground SNPs
		open (my $tempfile,  q{>}, $out_temp_INPUT_BACKGROUND) or die("Unable to open $out_temp_INPUT_BACKGROUND : $!");
		foreach my $col (@{$row}) {
			my ($chr, $pos) = split(":", $col);
	  		print $tempfile $chr . "\t" . ($pos - 1) . "\t" . $pos . "\n";
		}
		close $tempfile;
		#intersect
		$METRIC_BG = `sort -k1,1V -k2,2g $out_temp_INPUT_BACKGROUND | $BEDTOOLS intersect -a stdin -b $out_temp_buffer_singleph_bed_processed | wc -l`;
		unlink $out_temp_INPUT_BACKGROUND;
		chomp $METRIC_BG;
		push(@METRIC_BG, $METRIC_BG);
	}	
	#now you have, for this phenotype, an intersection for the foreground and 1000 intersections for the background
	#open R, calculate Z-score, save pvalue
	my ($obs, $exp, $fc, $l2fc, $pval) = get_stats($METRIC_FG,\@METRIC_BG);
	my $stats = $obs . "\t" . $exp . "\t" . $fc . "\t" . $l2fc . "\t" . $pval;
	$ph_to_stats{$item} = $stats;
	unlink $out_temp_buffer_singleph_bed;
	unlink $out_temp_buffer_singleph_bed_processed;
}


#get vector of pvalues
my @pvals;
foreach my $item (sort keys %ph_to_stats){
	my @fields = split("\t", $ph_to_stats{$item});
	push(@pvals, $fields[4]);
}
#call R and adjust pvalue:
#I think p.adjust is more suitable than "qvalue" see posts here:
#https://stat.ethz.ch/pipermail/bioconductor/2014-January/056982.html
my $R = Statistics::R->new();
$R->set('pvals', \@pvals);
$R->run(q`adjustp <- p.adjust(pvals, method = "BH", n = length(pvals))`);
my $corrected_pvals = $R->get('adjustp');
$R->stop();

my $counter = 0;
open (my $outstream,  q{>}, $out_results_noncorrected) or die("Unable to open $out_results_noncorrected : $!");
print $outstream "TRAIT\tOBSERVED\tEXPECTED\tFOLD\tLOG2_FOLD\tPVAL\tADJ_PVAL\n";
foreach my $item (sort keys %ph_to_stats){
	print $outstream $item . "\t" . $ph_to_stats{$item} . "\t" . $$corrected_pvals[$counter] . "\n";
	$counter++;
}
close $outstream;
print "*FINISHED*\n";
unlink $out_temp_buffer;
unlink $out_temp_buffer_ph_list;




####################
#subroutines
####################

#zscores
#http://stats.seandolinar.com/calculating-z-scores-with-r/

#http://www.cyclismo.org/tutorial/R/pValues.html

#http://blogs.sas.com/content/iml/2011/11/02/how-to-compute-p-values-for-a-bootstrap-distribution.html
#The simplest computation is to apply the definition of a p-value. To do this, count the number of values (statistics) that are greater than or equal to the observed value, and divide by the number of values. In code, pval = sum(s >= s0)/N;
#The previous formula has a bias due to finite sampling. Some authors suggest the modification pval = (1+sum(s >= s0))/(N+1); For example, see Davison and Hinkley (1997), Bootstrap Methods and their Application, p. 141. Obviously, the two formulas are essentially the same when the number of values, N, is large. 

sub get_stats{
	my ($value_fg, $values_bg) = @_;
	my $counter = 0;
	
	foreach my $item (@$values_bg){
		if($item >= $value_fg){
			$counter++;
		}
	}
	my $p =  ( ( 1 + $counter) / (@$values_bg + 1)    );
	#what is the expected value? the mean of the values in the randomisation?
	my $obs = $value_fg;
	my $exp	= mean(@$values_bg);
	my $fold_change;
	#if($exp > 0){
		$fold_change = ( 1.0 + $obs) / ( 1.0 + $exp);
	#}else{
	#	$fold_change = 'inf';
	#}
	return ($obs, $exp, $fold_change, log2($fold_change), $p);
}

sub log2 {
	my $n = shift;
	return log($n)/log(2);
}

sub mean {
    return sum(@_)/@_;
}

sub create_phenotype_bed{
	my ($this_ph, $outfile, $outfile_processed) = @_;
	
	open (my $temp_stream,  q{>}, $outfile) or die("Unable to open $outfile : $!");
	tie *FILE,   'IO::Zlib', $INPUT_GRASP_CEU_BLOCKS, "rb";
	while(<FILE>){
		chomp;
		next if($_ eq '');
		my ($ld_block_chr, $ld_block_start, $ld_block_stop, $phenotype) = (split /\t/)[0,1,2,11];
		if(lc($phenotype) eq $this_ph){
			my $line = $ld_block_chr . "\t" . $ld_block_start . "\t" . $ld_block_stop  . "\t" . $this_ph;
			print $temp_stream $line, "\n";
		}
	}
	close FILE;
	close $temp_stream;
	system "sort -k1,1V -k2,2g $outfile | $BEDTOOLS merge -i stdin > $outfile_processed";
}
