#!/usr/bin/perl
use strict;
use warnings;
use File::Basename;
use Getopt::Long;
use IO::Zlib;
use List::Util qw(sum);


#VET to test QTL and BROAD PICS associations
#I assume each of these annotations has only one type of annotation, so no p-val correction needed.

my $BIN_NUMBER = 20;
my $RANDOM_SETS = 1000;
my $INPUT_ANNOTATION;

#hash ethnicity ids
my $AFEUR  = 'AFEUR';
my $AFGLOB = 'AFGLOB';
my $AFAFR  = 'AFAFR'; 

#hardcoded annotation files (all hg19)
my $ANN_EQTL = "/net/isi-scratch/giuseppe/indexes/QTL_PRITCHARD/eQTL_onlylcl_v3.sorted.b37_cleanVET.bed.gz";
my $ANN_DSQTL = "/net/isi-scratch/giuseppe/indexes/QTL_PRITCHARD/DNASEqtl_degner.sorted.b37_cleanVET.bed.gz";
my $ANN_GEUVCEU = "/net/isi-scratch/giuseppe/indexes/GEUVADIS/EUR373.alltypes.cis.FDR5.all.rs137.GAT.bed.gz";
my $ANN_GEUVYRI = "/net/isi-scratch/giuseppe/indexes/GEUVADIS/YRI89.alltypes.cis.FDR5.all.rs137.GAT.bed.gz";
my $ANN_PICS = "/net/isi-scratch/giuseppe/VDR/ALLELESEQ/BROAD_PICS/BROAD_candidate_causal_snps_39immune_nonimmune_diseases_plus_enh_annot_masterfile9_VET_ANNOTATION_clean.bed.gz";

#############
#globals
#############
my %variants_1kg;
my %DAF_binning_FG;
my %DAF_binning_BG;
my @METRIC_BG = ();
my %annot_intervals; #hash of arrays

my $INPUT_FOREGROUND;
my $INPUT_BACKGROUND;
my $ALLELE_FREQ;
my $ANN_TYPE;

GetOptions(
        'fg=s'      =>\$INPUT_FOREGROUND,
        'bg=s'      =>\$INPUT_BACKGROUND,
        'af=s'      =>\$ALLELE_FREQ,
        'ann=s'     =>\$ANN_TYPE
);

my $USAGE = "USAGE: do_funseq_VET_02_QTL.pl -fg=<FG> -bg=<BG> -af=<daf|maf>  -ann=<eqtl|dsqtl|geuvceu|geuvyri|pics>\n" . 
    		"<FG> b37 bed.gz containing the LD-CLUMPED foreground SNPs [generated by do_funseq_ET_01_LDclump_FG_and_BG.pl]\n" .
    		"<BG> b37 vcf.gz containing the [LD-CLUMPED] background SNPs with MAF information [generated by do_funseq_ET_01_LDclump_FG_and_BG.pl]\n" . 
		"<af> allele frequency to consider: one of maf (alternate allele freq) or daf (derived allele freq)\n" .
		"<ann> annotation file to use - eqtl: pritchard LCL eqtl; dsqtl: degner LCL dsqtl; geuvceu/geuvyri: geuvadis LCL ceu/yri eqtl; pics: broad pics autoimmune"; 


if(!$INPUT_FOREGROUND){
	print $USAGE, "\n";
    exit 1;
}
if(!$INPUT_BACKGROUND){
	print $USAGE, "\n";  
    exit 1;
}
if(!$ALLELE_FREQ){
	print $USAGE, "\n";
    exit 1;
}
unless($ALLELE_FREQ eq 'maf' || $ALLELE_FREQ eq 'daf'){
	print $USAGE, "\n";
    exit 1;
}
if(!$ANN_TYPE){
	print $USAGE, "\n";
    exit 1;	
}
unless($ANN_TYPE eq 'eqtl' || $ANN_TYPE eq 'dsqtl' || $ANN_TYPE eq 'geuvceu' || $ANN_TYPE eq 'geuvyri' || $ANN_TYPE eq 'pics'){
	print $USAGE, "\n";
    exit 1;		
}

if($ANN_TYPE eq 'eqtl'){
	$INPUT_ANNOTATION = $ANN_EQTL;
}elsif($ANN_TYPE eq 'dsqtl'){
	$INPUT_ANNOTATION = $ANN_DSQTL;
}elsif($ANN_TYPE eq 'geuvceu'){
	$INPUT_ANNOTATION = $ANN_GEUVCEU;
}elsif($ANN_TYPE eq 'geuvyri'){
	$INPUT_ANNOTATION = $ANN_GEUVYRI;
}elsif($ANN_TYPE eq 'pics'){
	$INPUT_ANNOTATION = $ANN_PICS;
}else{
	print STDERR "Should not be here\n";
	exit -1;
}


my $ann_label = '_annot_' . $ANN_TYPE;
my $af_label  = '_match_' . $ALLELE_FREQ;

my($basename, $directory) = fileparse($INPUT_FOREGROUND);
my($basename_ann, $directory_ann) = fileparse($INPUT_ANNOTATION); #need this for the output

$basename_ann =~ s/(.*)\..*/$1/;
my $out_results             = $directory  . 'RESULTS_VET_QTL' . $ann_label  . $af_label . '.tsv';
my $out_temp_INPUT_BG       = $directory  . 'TEMP_VET_QTL'     . $ann_label  . $af_label . '_bgset.bed';


#############
#0 save annotation
#############
print STDERR "Collecting annotation variants..\n";

tie *FILE,   'IO::Zlib', $INPUT_ANNOTATION, "rb";
while(<FILE>){
	chomp;
	my ($chr,$pos) = (split /\t/)[0,2];
	$annot_intervals{$chr}{$pos} = 1;
}
close FILE;

#####################
#1 -build  hash to map chr-pos to DAF-CEU and DAF-YRI (the latter not needed now)
#####################
#before saving the frequencies, you need to to KNOW if the ancestral allele is the ref or the alt
#if the ancestral allele is the ref, save the frequency as is
#if the ancestral allele is the alt, the frequency you have is for the ancestral. The derived will be (1 - freq)
#however if you choose 'maf' below, you'll simply get what's reported in the AF field, without caring about ancestral allele

if($ALLELE_FREQ eq 'daf'){
	print STDERR "Collecting 1kg DAF..\n";
	get_DAF(\%variants_1kg);	
}elsif($ALLELE_FREQ eq 'maf'){
	print STDERR "Collecting 1kg MAF..\n";
	get_MAF(\%variants_1kg);	
}else{
	print STDERR "Should not be here. Aborting..\n";
	exit -1;
}


##############
#2 - bin foreground SNPs by DAF/MAF
##############
#open the foreground snps and query them to %variants_1kg
print STDERR "Binning FG variants..\n";

my ($total_fg_vars, $skipped_fg_vars, $valid_fg_vars)  = bin_variants($INPUT_FOREGROUND,\%DAF_binning_FG, 'fg');

print STDERR "$total_fg_vars total fg vars\n";
print STDERR "$skipped_fg_vars fg vars skipped (no key found/no DAF info found)\n";
print STDERR "Valid fg variants: $valid_fg_vars\n";
print STDERR "FOREGROUND DAF HISTOGRAM:\n";

print_histogram(\%DAF_binning_FG, 'fg');



##############
#3 - bin background SNPs by DAF/MAF
##############
print STDERR "\n\nBinning BG variants..\n";

my ($total_bg_vars, $skipped_bg_vars, $valid_bg_vars)  = bin_variants($INPUT_BACKGROUND,\%DAF_binning_BG, 'bg');

print STDERR "$total_bg_vars total bg vars\n";
print STDERR "$skipped_bg_vars bg vars skipped (no key found/no DAF info found)\n";
print STDERR "Valid bg variants: $valid_bg_vars\n";
print STDERR "BACKGROUND DAF HISTOGRAM:\n";

print_histogram(\%DAF_binning_BG, 'bg');

#cleanup
%variants_1kg = ();



####################
#4 - COMPUTE ENRICHMENTS - FG overlap
####################
#now you only have one phenotype, the QTL one. So you don't need the phenotype loop, and the pvalue correction
print STDERR "Processing enrichments..\n";
print STDERR "Getting fg overlap..\n";

my %test_vars;
tie *FILE,   'IO::Zlib', $INPUT_FOREGROUND, "rb";
while(<FILE>){
	chomp;
	my ($chr,$pos) = (split /\t/)[0,2];
	$test_vars{$chr}{$pos} = 1;
}
close FILE;

#see if the chr of the fg variant is in the annotation.
#if no move on to next chr;
#if yes, get position of the fg variant and check against all gwas intervals to see if it's in any
my $METRIC_FG = 0;
foreach my $chr (sort keys %test_vars){
	foreach my $pos (sort keys %{ $test_vars{$chr} }){
		$METRIC_FG++ if($annot_intervals{$chr}{$pos});
	}
}

if($METRIC_FG eq '0'){
	print STDERR "ERROR: zero intersections between foreground variants and annotation variants. Aborting..\n";
	exit -1;
}


############
#5 - COMPUTE ENRICHMENTS - BG overlap
############
print STDERR "Collecting $RANDOM_SETS sets of $valid_fg_vars frequency-matched background variants\n";
print STDERR "and getting bg overlaps..\n";

#create array of array containing 1000 random frequency matched sets
#for each foreground bin, count the number of instances in the bin, then get a random set of n instances from the background bin
#if the foreground bin is empty, keep the background bin empty.

while ($RANDOM_SETS > 0) {
	my @this_random_set;
	my $METRIC_BG = 0;
	
	for (0..$BIN_NUMBER){
		$_ = $_/$BIN_NUMBER;	 
	     if($DAF_binning_FG{$_}){
	     	my @all_bg_vars_this_bin;
	    	my @match_bg_vars_this_bin;  	
	    	my $n = $DAF_binning_FG{$_};
			#get n items at random from $DAF_binning_BG{$_}
			#you should chech that the background contains MORE variants than the fg
			#though you know it does for this particular bg/fg combination
			#my $n_bg = scalar(keys %{$DAF_binning_BG{$_}});
			#if($n > $n_bg).. 
			@all_bg_vars_this_bin = keys %{$DAF_binning_BG{$_}};
			#is there a way to get n random variants?
			push @match_bg_vars_this_bin, splice @all_bg_vars_this_bin, rand @all_bg_vars_this_bin, 1 while @match_bg_vars_this_bin < $n;			
			push(@this_random_set, @match_bg_vars_this_bin); #DOUBLE CHECK
	    }else{
	    	#there are no fg variants in this bin, there should be none in this bg then
	    	next;
	    }	
	}
	
	#enrichments
	foreach my $variant (@this_random_set){
		my ($chr, $pos) = split('-', $variant);	
		$METRIC_BG++ if($annot_intervals{$chr}{$pos});
	}		
	push(@METRIC_BG, $METRIC_BG);
	
	$RANDOM_SETS -= 1;
}


my ($obs, $exp, $fc, $l2fc, $pval) = get_stats($METRIC_FG,\@METRIC_BG);
my $stats = $obs . "\t" . $exp . "\t" . $fc . "\t" . $l2fc . "\t" . $pval . "\t" . $pval;


open (my $outstream,  q{>}, $out_results) or die("Unable to open $out_results : $!");
print $outstream "TRAIT\tOBSERVED\tEXPECTED\tFOLD\tLOG2_FOLD\tPVAL\tADJ_PVAL\n";
print $outstream $basename_ann . "\t" . $stats . "\n";
print "TRAIT\tOBSERVED\tEXPECTED\tFOLD\tLOG2_FOLD\tPVAL\tADJ_PVAL\n";
print $basename_ann . "\t" . $stats . "\n";
close $outstream;
print "*FINISHED*\n";









#------------------------------------------------------------------------------
#subs
#------------------------------------------------------------------------------
sub get_DAF{
	my ($hash) = @_;
	
	tie *FILE,   'IO::Zlib', $INPUT_BACKGROUND, "rb";
	while (<FILE>)	{ 
		chomp;
		next if($_ eq '');
		next if($_ =~ /^#/);
		#my $ALTF_AFR; #not doing anything with the african frequencies atm 
		my $AF_EUR; #ALTERNATE allele frequencies; many rare background SNPs don't have EUR allele freq
		my $AF_GLOB;
		my $ANC;
		my $FLAG; # set to one if the ancestral is the alternate	
	
		my @fields = split("\t", $_);
		#skip indels
		next if(length($fields[3]) > 1);
		next if(length($fields[4]) > 1);
		my $key =  $fields[0] . '-' . $fields[1];
		
		#get derived allele frequencies
		my $ref = $fields[3]; 
		my $alt = $fields[4];
		my @info = split(";", $fields[7]);
		
		#get ancestral allele info and allele frequencies=====================
		foreach my $item (@info){
			if($item =~ /^AA=(.*)/){
				$ANC = $1;
			}
			if($item =~ /^EUR_AF=(.+)/){
				$AF_EUR = $1;	
			}
			if($item =~ /^AF=(.+)/){
				$AF_GLOB = $1;
			}	
		}	
		next unless($ANC);
		
		if(uc($ANC) eq uc($alt)){
			$FLAG = 1;		
		}elsif(uc($ANC) eq uc($ref)){			
		}elsif( ($ANC eq '') or ($ANC eq 'N') or ($ANC eq '.') or ($ANC eq '-') ){
			next;
		}else{ 
			next;			
		}
	
		if($AF_GLOB){
			if($FLAG){
				if($AF_GLOB == 1){
						$$hash{$key}{$AFGLOB} = '0.0';			
				}else{
					$$hash{$key}{$AFGLOB} = (1 - $AF_GLOB);				
				}
			}else{
				$$hash{$key}{$AFGLOB} = $AF_GLOB;
			}
		}
		if($AF_EUR){
			if($FLAG){
				if($AF_EUR == 1){
						$$hash{$key}{$AFEUR} = '0.0';			
				}else{
					$$hash{$key}{$AFEUR} = (1 - $AF_EUR);				
				}
			}else{
				$$hash{$key}{$AFEUR} = $AF_EUR;
			}
		}		
	}
	close FILE;	
	return;
}


sub get_MAF{
	my ($hash) = @_;
	
	tie *FILE,   'IO::Zlib', $INPUT_BACKGROUND, "rb";
	while (<FILE>)	{ 
		chomp;
		next if($_ eq '');
		next if($_ =~ /^#/);
		#my $ALTF_AFR; #not doing anything with the african frequencies atm 
		my $AF_EUR; #ALTERNATE allele frequencies; many rare background SNPs don't have EUR allele freq
		my $AF_GLOB;
	
		my @fields = split("\t", $_);
		#skip indels
		next if(length($fields[3]) > 1);
		next if(length($fields[4]) > 1);
		my $key =  $fields[0] . '-' . $fields[1];
		
		my @info = split(";", $fields[7]);
		
		#get ancestral allele info and allele frequencies=====================
		foreach my $item (@info){
			if($item =~ /^EUR_AF=(.+)/){
				$AF_EUR = $1;	
			}
			if($item =~ /^AF=(.+)/){
				$AF_GLOB = $1;
			}	
		}	
		
		if($AF_GLOB){
			$$hash{$key}{$AFGLOB} = $AF_GLOB;
		}
		if($AF_EUR){
			$$hash{$key}{$AFEUR} = $AF_EUR;
		}		
	}
	close FILE;	
	return;
}

sub get_stats{
	my ($value_fg, $values_bg) = @_;
	my $counter = 0;
	
	foreach my $item (@$values_bg){
		if($item >= $value_fg){
			$counter++;
		}
	}
	my $p =  ( ( 1 + $counter) / (@$values_bg + 1)    );
	#what is the expected value? the mean of the values in the randomisation?
	my $obs = $value_fg;
	my $exp	= mean(@$values_bg);
	my $fold_change;
	#if($exp > 0){
		$fold_change = ( 1.0 + $obs) / ( 1.0 + $exp);
	#}else{
	#	$fold_change = 'inf';
	#}
	return ($obs, $exp, $fold_change, log2($fold_change), $p);
}

sub log2 {
	my $n = shift;
	return log($n)/log(2);
}

sub mean {
    return sum(@_)/@_;
}

############### binning ############
sub bin_variants{
	my ($file, $hash, $type) = @_;

	my $skipped = 0;
	my $valid = 0;
	my $total = 0;
	my %local_hash; #for the background the vcf is not unique, so fill hash. Do it also for the foreground, it won't hurt

	tie *FILE,   'IO::Zlib', $file, "rb";

	while (<FILE>)	{
		chomp;
		next if($_ eq '');
		next if($_ =~ /^#/);
		my $chr; my $pos;
	
		if($type eq 'fg'){ #fg is a bed
			($chr, $pos) = (split /\t/)[0,2];
		}elsif($type eq 'bg'){
			($chr, $pos) = (split /\t/)[0,1]; #vcf file
		}else{
			print STDERR "bin_variants(): type: $type not recognised. Aborting\n..";
			exit -1;
		}	
		my $key = $chr . '-' . $pos;
		$local_hash{$key} = 1;
	}
	close FILE;

	foreach my $item (keys %local_hash){
		$total++;		
		#TODO DISCARDING those VDR-BVs which don't have clear ANCESTRAl/DERIVED info - see what you're wasting here
		unless($variants_1kg{$item}){
			#print STDERR "Warning: background VDR-BV variant $item: key not found in background. Skipping..\n";
			$skipped++;
			next;
		}
	#	unless($variants_1kg{$item}{$AFEUR}){
	#		print STDERR "Warning: background VDR-BV variant at coordinates $item does not have DAF CEU info. Skipping..\n";
	#		$skipped_bg_vars++;
	#		next;		
	#	}
		unless($variants_1kg{$item}{$AFGLOB}){
			#print STDERR "Warning: background VDR-BV variant at coordinates $item does not have GLOB MAF info. Skipping..\n";
			$skipped++;
			next;		
		}
		#test that the DAF value is numeric?
		my $bin_id = int( $variants_1kg{$item}{$AFGLOB} * $BIN_NUMBER ) / $BIN_NUMBER;
		#Here we care about the coordinate of the variants composing the bin, and each should be present once, because we suppose they're unique
		if($type eq 'fg'){
			$$hash{$bin_id}++;
		}else{
			$$hash{$bin_id}{$item}++; 
		}
		$valid++;
	}
	return ($total, $skipped, $valid);
}


###############histogram##############
sub print_histogram{
	my ($hash, $type) = @_;
	
	if($type eq 'fg'){
		for (0..$BIN_NUMBER){
	    	$_ = $_/$BIN_NUMBER;
	    	if($$hash{$_}){ 
			    my $number_in_this_bin = $$hash{$_};    	
		    	print STDERR "$_\t" .$number_in_this_bin . "\n";    		
	    	}else{
		    	print STDERR "$_\t0\n";	    		
	    	}
	    }		
	}elsif($type eq 'bg'){
		for (0..$BIN_NUMBER){
	    	$_ = $_/$BIN_NUMBER;
	    	if(ref $$hash{$_}){ 
     			my $number_in_this_bin = scalar(keys %{$$hash{$_}});    	
	    		print STDERR "$_\t" .$number_in_this_bin . "\n";   		
	    	}else{
		    	print STDERR "$_\t0\n";	    		
	    	}
	    }				
	}else{
	    	print STDERR "Error: print_histogram() - type $type not recognised. Aborting..\n";
	    	exit -1;		
	}
	return;	
}
