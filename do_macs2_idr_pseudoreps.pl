#!/usr/bin/perl
use strict;
use warnings;
use threads;
use Getopt::Long;
use File::Basename;
#18/4/2013
#This calls peaks with MACS 2 and filters them based on IDR on pseudoreplicate
#Extracted it from encode_analyses.pl
#Ideally you call this in a shell script on the cluster

#input: bam file
#output: bed of peaks approved by IDR

my $infile;

my $IDR_THRESHOLD = 0.025;
my $MAPPABILITY = 2540757438;

my $SCRIPT_PATH     = '/net/isi-backup/giuseppe/scripts';
my $TOOL_PATH       = '/net/isi-scratch/giuseppe/tools';
my $R_CODE          = '/net/isi-cgat/ifs/apps/apps/R-2.14.1/bin';
my $IDR             = $TOOL_PATH . '/idrCode';

GetOptions(
	'i=s'  => \$infile
);

if(!$infile){
     print "USAGE: do_macs2_idr_pseudorep.pl -i=<INFILE>\n";
     print "<INFILE> input bam file\n";
     exit 1;
}
#I want all the outputs in a directory whose format will be $PATH/$input_id_saturation_data
my($bamfile, $directory) = fileparse($infile);
my $basename = $bamfile; $basename =~ s/(.*)\..*/$1/; #remove extension

my $infile_tagAlign         = $directory . $basename . '.tagAlign.gz';
my $infile_tagAlign_pr1     = $directory . $basename . '.pr1.tagAlign.gz';
my $infile_tagAlign_pr2     = $directory . $basename . '.pr2.tagAlign.gz';

my $macs2_basename          = $directory . $basename  . '_macs2'; 
my $macs2_pr1_basename      = $directory . $basename  . '_macs2_pr1';  #macs2 outputs here for pseudoreplicate 1
my $macs2_pr2_basename      = $directory . $basename  . '_macs2_pr2';  #macs2 outputs here for pseudoreplicate 1

#macs output full
my $macs2_encodePeak_file       = $macs2_basename . '_peaks.narrowPeak';
my $macs2_encodePeak_file_thrs  = $macs2_basename . '_peaks-thrs.narrowPeak';
#macs output pseudorep 1 
my $macs2_pr1_encodePeak_file    = $macs2_pr1_basename . '_peaks.narrowPeak';
my $macs2_pr1_regionPeak_file    = $macs2_pr1_basename . '.regionPeak';
my $macs2_pr1_regionPeak_gz_file = $macs2_pr1_basename . '.regionPeak.gz';
#macs pseudorep 2
my $macs2_pr2_encodePeak_file    = $macs2_pr2_basename . '_peaks.narrowPeak';
my $macs2_pr2_regionPeak_file    = $macs2_pr2_basename . '.regionPeak';
my $macs2_pr2_regionPeak_gz_file = $macs2_pr2_basename . '.regionPeak.gz';

my $idr_basename                = $directory . $basename  . '_pr1VSpr2';
my $idr_plot_basename           = $directory . $basename  . '_IDR_plot';#done only for full, not random
my $idr_overlap_file            = $idr_basename           . '-overlapped-peaks.txt';
my $idr_overlap_file_thrs       = $idr_basename           . '-overlapped-peaks-thrs.txt';
my $idr_encodepeak_file         = $idr_overlap_file_thrs  . '.npk'; # generated by idrOverlap2npk.sh #input to bedtools multicov

my $output_file_idr                 = $directory . $basename . '_idr_out.bed';
my $output_file_macs                = $directory . $basename . '_idr_thresholded_macs_out.bed';

$directory  = substr($directory, 0, -1);
#---------------
#bam -> tagalign
#---------------
print "-----------------------\n";
print "INFO - bam -> tagalign\n";
print "-----------------------\n";
system "$SCRIPT_PATH/do_bam_to_tagalign.sh $infile $directory";
#------------------------
# create pseudoreplicates for MACS2 IDR from tagalign file
#------------------------
print "-----------------------\n";
print "INFO - do_random_split_peakfile.sh: create two random subsets of tagAlign file\n";
print "-----------------------\n";
system "$SCRIPT_PATH/do_random_split_peakfile.sh $infile_tagAlign $directory";
#-------------------------------
# call peaks on full file and pseudoreplicates (threaded) with MACS2
#-------------------------------
print "-----------------------\n";
print "INFO - MACS2: Call peaks pseudoreplicates and full file\n";
print "-----------------------\n";
my $thread_macs2      = threads->create( \&run_macs2,  $infile_tagAlign,     $macs2_basename);
my $thread_macs2_pr1  = threads->create( \&run_macs2,  $infile_tagAlign_pr1, $macs2_pr1_basename);
my $thread_macs2_pr2  = threads->create( \&run_macs2,  $infile_tagAlign_pr2, $macs2_pr2_basename);
$thread_macs2->join;
$thread_macs2_pr1->join;
$thread_macs2_pr2->join;
if (my $err = $thread_macs2->error())     { warn("Thread run_macs2() error: $err\n"); } 
if (my $err = $thread_macs2_pr1->error()) { warn("Thread run_macs2() error: $err\n"); } 
if (my $err = $thread_macs2_pr1->error()) { warn("Thread run_macs2() error: $err\n"); } 
#---------------------------------
#sort MACS2 output encodePeak file rep1 and rep2 (threaded)
#---------------------------------
print "-----------------------\n";
print "INFO - sort pseudoreps and get top 100,000\n";
print "-----------------------\n";
my $full_thread_sort_pr1  = threads->create( \&sort_pseudorep,  $macs2_pr1_encodePeak_file, $macs2_pr1_regionPeak_file);
my $full_thread_sort_pr2  = threads->create( \&sort_pseudorep,  $macs2_pr2_encodePeak_file, $macs2_pr2_regionPeak_file);
$full_thread_sort_pr1->join;
$full_thread_sort_pr2->join;
if (my $err = $full_thread_sort_pr1->error()) { warn("Thread sort_pseudorep() error: $err\n"); } 
if (my $err = $full_thread_sort_pr2->error()) { warn("Thread sort_pseudorep() error: $err\n"); }
#------------
#IDR Analysis
#------------
print "-----------------------\n";
print "INFO - IDR run on pseudoreplicates\n";
print "-----------------------\n";
system "$R_CODE/Rscript $IDR/batch-consistency-analysis.r $macs2_pr1_regionPeak_file $macs2_pr2_regionPeak_file -1 $idr_basename 0 F p.value";
system "$R_CODE/Rscript $IDR/batch-consistency-plot.r 1 $idr_plot_basename  $idr_basename";
my $IDR_peaks = `$SCRIPT_PATH/idr_get_peaks.sh  $idr_overlap_file $IDR_THRESHOLD | wc -l`; #get the number of peak which pass the threshold
chomp $IDR_peaks;
print 'There are: ' . $IDR_peaks . ' peaks which pass the threshold: ' . $IDR_THRESHOLD .  "\n";
#----------------
#IDR - get candidate peak list
#----------------
#1st method - Sort MACS2 peaks in the full file by p.value before selecting the top N peaks, where N is the number of peaks which pass the IDR threshold
#----------------------
system "cat $macs2_encodePeak_file | sort -k8nr,8nr | head -n $IDR_peaks > $macs2_encodePeak_file_thrs";
#get beds because igv does not seem to be able to read narrowPeak files
system "$SCRIPT_PATH/narrowPeak_to_bed.pl -i=$macs2_encodePeak_file_thrs > $output_file_macs";

#2nd method - get subset of -overlapped-peaks.txt that pass $IDR_THRESHOLD ($idr_overlap_file_thrs)
#----------------------
system "$SCRIPT_PATH/idr_get_peaks.sh $idr_overlap_file $IDR_THRESHOLD > $idr_overlap_file_thrs";
system "$SCRIPT_PATH/idrOverlap2npk.sh $idr_overlap_file_thrs";#output in $idr_encodepeak_file
system "$SCRIPT_PATH/narrowPeak_to_bed.pl -i=$idr_encodepeak_file > $output_file_idr";


unlink $infile_tagAlign;
unlink $infile_tagAlign_pr1;
unlink $infile_tagAlign_pr2;
system "rm -rf $macs2_basename*"; #remove macs2 output
system "rm -rf $idr_basename*"; #remove IDR output (but not the plot)
print "FINISHED", "\n";


#-----------
#subs
#-----------
sub run_macs2{
	my ( $input_file, $macs2_basename ) = @_;
	#${PCODE}/macs2 callpeak -t ${FILE} -n ${PDATA}/${ID} -g 2540757438 --keep-dup=all -q 0.001 --nomodel --extsize 26 --call-summits
	#system "macs2 callpeak -t :
	#macs2 callpeak -t $infile_tagAlign_gz -f BED -n $full_macs2_basename -g $MAPPABILITY --keep-dup=all --nomodel --extsize 26 -p 1e-3 --to-large
	#system "macs2 callpeak -t $input_file -f BED -n $macs2_basename -g $MAPPABILITY --keep-dup=all --nomodel --extsize 26 -p 1e-3 --verbose 1 --nolambda --llocal 0";
	system "macs2 callpeak -t $input_file -f BED -n $macs2_basename -g $MAPPABILITY --keep-dup=auto --nomodel --extsize 26 -p 1e-3 --verbose 1";
	#system "macs2 callpeak -t $input_file -f BED -n $macs2_basename -g $MAPPABILITY --keep-dup=1 --nomodel --extsize 26 -p 1e-3 --verbose 1";
	if ( $? == -1 ){
		print "MACS2: problem with output: $!\n";
        exit -1;
    }
    return;	
}
sub sort_pseudorep{
	my ( $encodePeak_file, $regionPeak_file ) = @_;
	system "sort -k 8nr,8nr $encodePeak_file | head -n 100000 > $regionPeak_file";
	return;
}
